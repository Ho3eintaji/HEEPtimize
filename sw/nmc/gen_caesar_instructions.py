import sys
import os
from datetime import date

today = date.today()

sv_instruction_type = "logic [5:0]"
sv_width_type = "logic [1:0]"

instructions = {
      "CSRW"      : int("0x00",16),
      "SHIFT_R"   : int("0x01",16),
      "SHIFT_L"   : int("0x02",16),
      "SUB"       : int("0x03",16),
      "ADD"       : int("0x04",16),
      "OR"        : int("0x05",16),
      "XOR"       : int("0x06",16),
      "AND"       : int("0x07",16),
      "MULT"      : int("0x08",16),
      "MAC_FIRST" : int("0x09",16),
      "MAC"       : int("0x0A",16),
      "STORE_MAC" : int("0x0B",16),
      "MIN"       : int("0x0C",16),
      "MAX"       : int("0x0D",16),
      "DOT_FIRST" : int("0x0E",16),
      "DOT"       : int("0x0F",16),
      "STORE_DOT" : int("0x10",16),
      "MAC_RELU"  : int("0x11",16)

}

widths = {
      "WORD_32B"  : int("0x00",16),
      "WORD_16B"  : int("0x01",16),
      "WORD_8B"   : int("0x02",16)
}


fsv = open("caesar_instructions_pkg.sv", "w")

header = "// This file is generated by gen_caesar_instruction.py on " + str(today)

fsv.write(header + "\n")
fsv.write("package caesar_instructions_pkg;" + "\n\n\n")
fsv.write("typedef enum " + sv_instruction_type + " {" + "\n")

for opcode, value in instructions.items():
    if opcode != list(instructions.keys())[-1]:
        fsv.write("     " + opcode + " = " + str(value) + ",\n")
    else:
        fsv.write("     " + opcode + " = " + str(value) + "\n")

fsv.write("} alu_op_t  /* verilator public */;"+ "\n\n\n")

fsv.write("typedef enum " + sv_width_type + " {" + "\n")

for opcode, value in widths.items():
    if opcode != list(widths.keys())[-1]:
        fsv.write("     " + opcode + " = " + str(value) + ",\n")
    else:
        fsv.write("     " + opcode + " = " + str(value) + "\n")

fsv.write("} data_width_t  /* verilator public */;"+ "\n\n\n")

fsv.write("endpackage"+ "\n")
fsv.close()

fcpp = open("caesar_instructions.hh", "w")

header = "// This file is generated by gen_caesar_instruction.py on " + str(today)

fcpp.write(header + "\n")
fcpp.write("#ifndef CAESAR_INSTRUCTION_GEN_H" + "\n")
fcpp.write("#define CAESAR_INSTRUCTION_GEN_H" + "\n\n\n")

fcpp.write("constexpr char width_str[" + str(len(widths)) + "][10]" + " = {\n\n\n")
for opcode, value in widths.items():
    if opcode != list(widths.keys())[-1]:
        fcpp.write("     " + '"' + opcode + '"' + ",\n")
    else:
        fcpp.write("     " + '"' + opcode + '"' + "\n")
fcpp.write("};\n\n\n")

fcpp.write("enum elm_width_e {\n\n\n")
for opcode, value in widths.items():
    if opcode != list(widths.keys())[-1]:
        fcpp.write("     " + opcode + "= " + str(value) +",\n")
    else:
        fcpp.write("     " + opcode + "= " + str(value) +"\n")
fcpp.write("};\n\n\n")


fcpp.write("constexpr char op_str[" + str(len(instructions)) + "][16]" + " = {\n\n\n")
sorted_instructions = {k: v for k, v in sorted(instructions.items(), key=lambda item: item[1])}

for opcode, value in sorted_instructions.items():
    if opcode != list(sorted_instructions.keys())[-1]:
        fcpp.write("     " + '"' + opcode + '"' + ",\n")
    else:
        fcpp.write("     " + '"' + opcode + '"' + "\n")
fcpp.write("};\n\n\n")


fcpp.write("#endif"+ "\n")
fcpp.close()

def get_opcode2string(opcode):
    value = instructions[opcode]
    return f'{value:06b}'

def get_address2string(address):
    return f'{address:013b}'

def get_width2string(width):
    #To get the value of the dictionary
    value = widths[width]
    # To take only the last 13 bits (2 are sufficient but i keep the same way of proceeding as with the addresses)
    #rthis f function return a string
    return f'{value:013b}'  